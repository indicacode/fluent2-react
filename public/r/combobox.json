{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "combobox",
  "title": "Combobox",
  "description": "Fluent2Tailwind Combobox component.",
  "dependencies": [
    "cmdk",
    "lucide-react",
    "react",
    "tailwind-variants"
  ],
  "files": [
    {
      "path": "registry/fluent2tailwind/combobox/combobox.parts.tsx",
      "content": "\"use client\"\n\nimport { Badge } from \"@/registry/fluent2tailwind/badge/badge\"\nimport { Checkbox } from \"@/registry/fluent2tailwind/checkbox/checkbox\"\nimport { CommandEmpty } from \"@/registry/fluent2tailwind/customCommandEmpty/customCommandEmpty\"\nimport { CommandGroup, CommandItem } from \"@/registry/fluent2tailwind/command/command\"\nimport { X } from \"lucide-react\"\nimport * as React from \"react\"\nimport { Option } from \"./combobox.types\"\n\nexport function SelectedBadges({\n  selected,\n  badgeClassName,\n  disabled,\n  badgeClass,\n  badgeIconClass,\n  onUnselect,\n}: {\n  selected: Option[]\n  badgeClassName?: string\n  disabled?: boolean\n  badgeClass: string\n  badgeIconClass: string\n  onUnselect: (option: Option) => void\n}) {\n  if (!selected.length) return null\n\n  return (\n    <div className=\"flex h-fit gap-1\">\n      {selected.map((option) => (\n        <Badge\n          key={option.value}\n          className={`${badgeClass} ${badgeClassName ?? \"\"}`}\n          data-fixed={option.fixed}\n          data-disabled={disabled}\n          onClick={() => onUnselect(option)}\n          onKeyDown={(event) => {\n            if (event.key === \"Enter\") {\n              onUnselect(option)\n            }\n          }}\n          onMouseDown={(event) => {\n            event.preventDefault()\n            event.stopPropagation()\n          }}\n        >\n          {option.label}\n          <X className={badgeIconClass} />\n        </Badge>\n      ))}\n    </div>\n  )\n}\n\nexport function CreatableItem({\n  creatable,\n  selected,\n  inputValue,\n  maxSelected,\n  onMaxSelected,\n  onChange,\n  onSearch,\n  debouncedSearchTerm,\n  isLoading,\n  setInputValue,\n  setSelected,\n}: {\n  creatable: boolean\n  selected: Option[]\n  inputValue: string\n  maxSelected: number\n  onMaxSelected?: (maxLimit: number) => void\n  onChange?: (options: Option[]) => void\n  onSearch?: (value: string) => Promise<Option[]>\n  debouncedSearchTerm: string\n  isLoading: boolean\n  setInputValue: (value: string) => void\n  setSelected: (options: Option[]) => void\n}) {\n  if (!creatable) return null\n  if (!inputValue.length) return null\n  if (selected.some((item) => item.label === inputValue)) return null\n\n  function Item() {\n    return (\n      <CommandItem\n        value={inputValue}\n        className=\"cursor-pointer\"\n        onMouseDown={(event) => {\n          event.preventDefault()\n          event.stopPropagation()\n        }}\n        onSelect={(value: string) => {\n          if (selected.length >= maxSelected) {\n            onMaxSelected?.(selected.length)\n            return\n          }\n          setInputValue(\"\")\n          const newOptions = [...selected, { value, label: value }]\n          setSelected(newOptions)\n          onChange?.(newOptions)\n        }}\n      >{`Create \"${inputValue}\"`}</CommandItem>\n    )\n  }\n\n  if (!onSearch && inputValue.length > 0) {\n    return <Item />\n  }\n\n  if (onSearch && debouncedSearchTerm.length > 0 && !isLoading) {\n    return <Item />\n  }\n\n  return null\n}\n\nexport function EmptyItem({\n  emptyIndicator,\n  onSearch,\n  creatable,\n  options,\n}: {\n  emptyIndicator?: React.ReactNode\n  onSearch?: (value: string) => Promise<Option[]>\n  creatable: boolean\n  options: Record<string, Option[]>\n}) {\n  if (!emptyIndicator) return null\n\n  if (onSearch && !creatable && Object.keys(options).length === 0) {\n    return (\n      <CommandItem value=\"-\" disabled>\n        {emptyIndicator}\n      </CommandItem>\n    )\n  }\n\n  return <CommandEmpty className=\"\">{emptyIndicator}</CommandEmpty>\n}\n\nexport function OptionsList({\n  options,\n  multiselect,\n  selected,\n  onSelectOption,\n  onUnselect,\n  commandItemClass,\n}: {\n  options: Record<string, Option[]>\n  multiselect: boolean\n  selected: Option[]\n  onSelectOption: (option: Option) => void\n  onUnselect: (option: Option) => void\n  commandItemClass: (disabled?: boolean) => string\n}) {\n  return (\n    <>\n      {Object.entries(options).map(([key, dropdowns]) => (\n        <CommandGroup className=\"h-full min-w-56 p-0\" heading={key} key={key}>\n          {dropdowns.map((option) => (\n            <CommandItem\n              disabled={option.disable}\n              value={option.value}\n              key={option.value}\n              onMouseDown={(event) => {\n                event.preventDefault()\n                event.stopPropagation()\n              }}\n              onSelect={() => {\n                if (multiselect && selected.some((item) => item.value === option.value)) {\n                  onUnselect(option)\n                  return\n                }\n                onSelectOption(option)\n              }}\n              className={commandItemClass(option.disable)}\n            >\n              {multiselect && (\n                <Checkbox\n                  checked={selected.some((item) => item.value === option.value)}\n                />\n              )}\n              {option.label}\n            </CommandItem>\n          ))}\n        </CommandGroup>\n      ))}\n    </>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/fluent2tailwind/combobox/combobox.tsx",
      "content": "\"use client\"\nimport portalRoot from \"@/utils/portal-root\"\nimport { useDebounce } from \"@/utils/useDebounce\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { X } from \"lucide-react\"\nimport * as React from \"react\"\nimport {\n  forwardRef,\n  Ref,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from \"react\"\nimport { tv } from \"tailwind-variants\"\n\nimport { Command, CommandItem, CommandList } from \"@/registry/fluent2tailwind/command/command\"\nimport {\n  GroupOption,\n  MultipleSelectorProps,\n  MultipleSelectorRef,\n  Option,\n} from \"./combobox.types\"\nimport { Input } from \"../input/input\"\nimport { Popover, PopoverContent, PopoverTrigger } from \"../popover/popover\"\nimport {\n  CreatableItem,\n  EmptyItem,\n  OptionsList,\n  SelectedBadges,\n} from \"./combobox.parts\"\n\nfunction transferToGroupOption(options: Array<Option>, groupBy?: string) {\n  if (options.length === 0) {\n    return {}\n  }\n\n  if (!groupBy) {\n    return {\n      \"\": options,\n    }\n  }\n\n  const groupOption: GroupOption = {}\n  options.forEach((option) => {\n    const key = (option[groupBy] as string) || \"\"\n    if (!groupOption[key]) {\n      groupOption[key] = []\n    }\n    groupOption[key].push(option)\n  })\n  return groupOption\n}\n\n//-----------------------------STYLES---------------------------------//\nconst combobox = tv({\n  slots: {\n    badge:\n      \"data-disabled:bg-muted data-disabled:text-muted-foreground data-disabled:hover:bg-muted data-fixed:bg-muted data-fixed:text-muted-foreground data-fixed:hover:bg-muted flex cursor-pointer items-center justify-center gap-1 rounded-full bg-primary py-1\",\n    badgeIcon: \"text-muted-foreground hover:text-foreground h-3 w-3\",\n    commandList:\n      \"animate-in flex w-56 justify-start rounded-md border p-0.5 shadow-md outline-hidden\",\n    commandItem: \"flex w-full cursor-pointer gap-1.5 rounded-none\",\n    commandRoot: \"overflow-visible bg-transparent\",\n    input: \"min-w-56 px-2\",\n    inputClearable: \"absolute top-1/2 right-1 -translate-y-1/2\",\n  },\n  variants: {\n    disabled: {\n      true: { commandItem: \"text-muted-foreground cursor-default\" },\n    },\n  },\n})\n\nconst {\n  badge,\n  badgeIcon,\n  commandItem,\n  commandList,\n  commandRoot,\n  input,\n  inputClearable,\n} = combobox({})\n//-----------------------------STYLES-------------------------------//\n\nconst Combobox = forwardRef<MultipleSelectorRef, MultipleSelectorProps>(\n  (\n    {\n      defaultOptions: arrayDefaultOptions = [],\n      maxSelected = Number.MAX_SAFE_INTEGER,\n      triggerSearchOnFocus = false,\n      hidePlaceholderWhenSelected,\n      selectFirstItem = true,\n      mountNode = portalRoot,\n      options: arrayOptions,\n      multiselect = false,\n      clearable = false,\n      creatable = false,\n      loadingIndicator,\n      selectedOptions,\n      badgeClassName,\n      emptyIndicator,\n      onMaxSelected,\n      onOpenChange,\n      commandProps,\n      tags = false,\n      placeholder,\n      defaultOpen,\n      inputProps,\n      className,\n      onSearch,\n      onChange,\n      disabled,\n      variant,\n      groupBy,\n      delay,\n      size,\n      open,\n    }: MultipleSelectorProps,\n    ref: Ref<MultipleSelectorRef>\n  ) => {\n    const [options, setOptions] = useState<GroupOption>(\n      transferToGroupOption(arrayDefaultOptions, groupBy)\n    )\n    const [selected, setSelected] = useState<Option[]>(selectedOptions || [])\n    const [isLoading, setIsLoading] = useState(false)\n    const [inputValue, setInputValue] = useState(\"\")\n\n    const debouncedSearchTerm = useDebounce(inputValue, delay || 500)\n\n    const inputRef = useRef<HTMLInputElement>(null)\n\n    //------------------------------------------------------------------//\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        selectedValue: [...selected],\n        input: inputRef.current as HTMLInputElement,\n      }),\n      [selected]\n    )\n\n    //------------------------------------------------------------------//\n\n    function handleUnselect(option: Option) {\n      const newOptions = selected.filter((s) => s.value !== option.value)\n      setSelected(newOptions)\n      onChange?.(newOptions)\n    }\n\n    //------------------------------------------------------------------//\n\n    useEffect(() => {\n      if (selectedOptions) {\n        setSelected(selectedOptions)\n      }\n    }, [selectedOptions])\n\n    //----If `onSearch` is provided, do not trigger options updated.-----//\n    useEffect(() => {\n      if (!arrayOptions || onSearch) {\n        return\n      }\n      const newOption = transferToGroupOption(arrayOptions || [], groupBy)\n      if (JSON.stringify(newOption) !== JSON.stringify(options)) {\n        setOptions(newOption)\n      }\n    }, [arrayDefaultOptions, arrayOptions, groupBy, onSearch, options])\n\n    //------------------------------------------------------------------//\n\n    useEffect(() => {\n      const doSearch = async () => {\n        setIsLoading(true)\n        const res = await onSearch?.(debouncedSearchTerm)\n        setOptions(transferToGroupOption(res || [], groupBy))\n        setIsLoading(false)\n      }\n\n      const exec = async () => {\n        if (!onSearch || !open) return\n\n        if (triggerSearchOnFocus) {\n          await doSearch()\n        }\n\n        if (debouncedSearchTerm) {\n          await doSearch()\n        }\n      }\n\n      void exec()\n    }, [debouncedSearchTerm, groupBy, open, triggerSearchOnFocus])\n\n    //------------------------------------------------------------------//\n\n    //---Avoid Creatable Selector freezing or lagging when paste a long string.---//\n    function commandFilter() {\n      if (commandProps?.filter) {\n        return commandProps.filter\n      }\n\n      if (creatable) {\n        return (value: string, search: string) => {\n          return value.toLowerCase().includes(search.toLowerCase()) ? 1 : -1\n        }\n      }\n      // Using default filter in `cmdk`. We don't have to provide it.\n      return undefined\n    }\n\n    //------------------------------------------------------------------//\n\n    function handleOptionSelect(option: Option) {\n      if (!multiselect) {\n        setInputValue(option.label)\n        setSelected([option])\n        return\n      }\n      if (selected.length >= maxSelected) {\n        onMaxSelected?.(selected.length)\n        return\n      }\n      const newOptions = [...selected, option]\n      setSelected(newOptions)\n      onChange?.(newOptions)\n    }\n\n    return (\n      <Popover\n        open={open}\n        defaultOpen={defaultOpen}\n        onOpenChange={onOpenChange}\n      >\n        <div className=\"flex min-h-fit flex-col gap-1\">\n          {multiselect && tags && (\n            <SelectedBadges\n              selected={selected}\n              badgeClassName={badgeClassName}\n              disabled={disabled}\n              badgeClass={badge({})}\n              badgeIconClass={badgeIcon()}\n              onUnselect={handleUnselect}\n            />\n          )}\n          <Command\n            onKeyDown={(e) => {\n              if (\n                e.key === \"Backspace\" &&\n                !multiselect &&\n                selected.length > 0\n              ) {\n                setSelected([])\n                setInputValue(\"\")\n              }\n            }}\n            {...commandProps}\n            className={commandRoot({ className: commandProps?.className })}\n            shouldFilter={\n              commandProps?.shouldFilter !== undefined\n                ? commandProps.shouldFilter\n                : !onSearch\n            } // When onSearch is provided, we don't want to filter the options. You can still override it.\n            filter={commandFilter()}\n          >\n            <PopoverTrigger className=\"relative\">\n              <Input\n                className={input({ className })}\n                disabled={disabled}\n                value={inputValue}\n                size={size}\n                variant={variant}\n                {...inputProps}\n                ref={inputRef}\n                onChange={(e) => {\n                  if (!multiselect && selected.length > 0) {\n                    return\n                  }\n                  setInputValue(e.target.value)\n                  inputProps?.onChange?.(e)\n                }}\n                onBlur={(event) => {\n                  inputProps?.onBlur?.(event)\n                }}\n                onFocus={(event) => {\n                  triggerSearchOnFocus && onSearch?.(debouncedSearchTerm)\n                  inputProps?.onFocus?.(event)\n                }}\n                placeholder={\n                  hidePlaceholderWhenSelected && selected.length !== 0\n                    ? \"\"\n                    : placeholder\n                }\n              />\n              {clearable && (\n                <X\n                  className={inputClearable()}\n                  onClick={() => {\n                    setSelected([])\n                    setInputValue(\"\")\n                  }}\n                />\n              )}\n            </PopoverTrigger>\n            <CommandPrimitive.Input\n              //@ts-ignore*\n              value={inputValue}\n              {...inputProps}\n              hidden\n            />\n            <PopoverContent\n              side=\"bottom\"\n              align=\"start\"\n              className=\"w-radix-popover-trigger\"\n              onOpenAutoFocus={(e) => e.preventDefault()}\n              container={mountNode}\n              autoFocus={false}\n              asChild\n            >\n              <CommandList className={commandList()}>\n                {isLoading ? (\n                  <>{loadingIndicator}</>\n                ) : (\n                  <>\n                    <EmptyItem\n                      emptyIndicator={emptyIndicator}\n                      onSearch={onSearch}\n                      creatable={creatable}\n                      options={options}\n                    />\n                    <CreatableItem\n                      creatable={creatable}\n                      selected={selected}\n                      inputValue={inputValue}\n                      maxSelected={maxSelected}\n                      onMaxSelected={onMaxSelected}\n                      onChange={onChange}\n                      onSearch={onSearch}\n                      debouncedSearchTerm={debouncedSearchTerm}\n                      isLoading={isLoading}\n                      setInputValue={setInputValue}\n                      setSelected={setSelected}\n                    />\n                    {!selectFirstItem && (\n                      <CommandItem value=\"-\" className=\"hidden\" />\n                    )}\n                    <OptionsList\n                      options={options}\n                      multiselect={multiselect}\n                      selected={selected}\n                      onSelectOption={handleOptionSelect}\n                      onUnselect={handleUnselect}\n                      commandItemClass={(disabled) =>\n                        commandItem({ disabled })\n                      }\n                    />\n                  </>\n                )}\n              </CommandList>\n            </PopoverContent>\n          </Command>\n        </div>\n      </Popover>\n    )\n  }\n)\n\nCombobox.displayName = \"Combobox\"\nexport default Combobox\n",
      "type": "registry:component"
    },
    {
      "path": "registry/fluent2tailwind/combobox/combobox.types.ts",
      "content": "import * as React from \"react\"\nimport { ReactNode } from \"react\"\n\nimport { Input } from \"@/registry/fluent2tailwind/input/input\"\nimport { Command } from \"@/registry/fluent2tailwind/command/command\"\n\nexport interface MultipleSelectorProps {\n  /** Props of `CommandInput` */\n  inputProps?: Omit<\n    React.ComponentPropsWithoutRef<typeof Input>,\n    \"variant\" | \"className\"\n  >\n  variant?: \"outline\" | \"underline\" | \"filledDark\" | \"filledLight\"\n  /** Props of `Command` */\n  commandProps?: React.ComponentPropsWithoutRef<typeof Command>\n  /** async search */\n  onSearch?: (value: string) => Promise<Option[]>\n  /** When the number of selected options exceeds the limit, the onMaxSelected will be called. */\n  onMaxSelected?: (maxLimit: number) => void\n  onChange?: (options: Option[]) => void\n  /** Hide the placeholder when there are options selected. */\n  hidePlaceholderWhenSelected?: boolean\n  /** Loading component. */\n  loadingIndicator?: React.ReactNode\n  /** Empty component. */\n  emptyIndicator?: React.ReactNode\n  /**\n   * Only work with `onSearch` prop. Trigger search when `onFocus`.\n   * For example, when user click on the input, it will trigger the search to get initial options.\n   **/\n  triggerSearchOnFocus?: boolean\n  /**\n   * First item selected is a default behavior by cmdk. That is why the default is true.\n   * This is a workaround solution by add a dummy item.\n   *\n   * @reference: https://github.com/pacocoursey/cmdk/issues/171\n   */\n  selectFirstItem?: boolean\n  /** Default value for the Combobox.\n   * @remarks\n   * DO NOT pass duplicated values, they are used as keys*/\n  defaultOptions?: Option[]\n  /** Callback when the open/closed state of the dropdown changes */\n  onOpenChange?: () => void\n  /** Control the size of the combobox. */\n  size?: \"sm\" | \"md\" | \"lg\"\n  badgeClassName?: string\n  /** Where the portal children are mounted on DOM\n   * @remarks\n   * The default value is `{@link portalRoot} or undefined */\n  mountNode?: HTMLElement | null\n  /** Whether the combobox allows multiple selections. */\n  multiselect?: boolean\n  placeholder?: string\n  /** Limit the maximum number of selected options. */\n  maxSelected?: number\n  /** Whether the combobox is open by default.\n   *\n   * @remarks\n   * Use only when combobox is uncontrolled.\n   * */\n  defaultOpen?: boolean\n  /** Allow user to create option when there is no option matched. */\n  creatable?: boolean\n  /** Determine if the input will have a clearable icon/function */\n  clearable?: boolean\n  /** Custom classes for the combobox\n   * @remarks\n   * This styles will be applied to the {@link Input} component*/\n  className?: string\n  disabled?: boolean\n  /** Manually controlled options. */\n  options?: Option[]\n  /** Group the options base on provided key. */\n  groupBy?: string\n  selectedOptions?: Option[]\n  /** Debounce time for async search. Only work with `onSearch`. */\n  delay?: number\n  /** Whether the combobox will display tags for selected options.\n   *\n   * @remarks\n   * Only work if `multiselect === true`.\n   */\n  tags?: boolean\n  /** Control the open/close state of the dropdown.\n   *\n   * @remarks\n   * Use together with onOpenChange to fully control the dropdown's visibility*/\n  open?: boolean\n}\n\nexport interface MultipleSelectorRef {\n  selectedValue: Option[]\n  input: HTMLInputElement\n}\n\nexport interface Option {\n  value: string\n  label: string\n  disable?: boolean\n  /** fixed option that can't be removed. */\n  fixed?: boolean\n\n  /** Group the options by providing key. */\n  [key: string]: string | boolean | undefined\n}\n\nexport interface GroupOption {\n  [key: string]: Option[]\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:component"
}