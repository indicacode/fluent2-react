{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "popover",
  "title": "Popover",
  "description": "Fluent2Tailwind Popover component.",
  "dependencies": [
    "@radix-ui/react-popover",
    "react",
    "tailwind-variants"
  ],
  "files": [
    {
      "path": "registry/fluent2tailwind/popover/popover.tsx",
      "content": "import {\n  Anchor,\n  Arrow,\n  Content,\n  Portal,\n  Root,\n  Trigger,\n} from \"@radix-ui/react-popover\"\nimport * as React from \"react\"\nimport { ComponentProps, useEffect, useRef, useState } from \"react\"\nimport { tv } from \"tailwind-variants\"\n\nconst popoverSlots = tv({\n  slots: {\n    content:\n      \"rounded-sm bg-popover p-2 text-xs text-popover-foreground shadow-xl will-change-[transform,opacity] focus:outline-hidden\" +\n      \" radix-state-closed:animate-out radix-state-closed:fade-out-0 radix-state-open:animate-in focus:ring-0\" +\n      \" data-[side=bottom]:slide-in-from-top-2 radix-state-closed:zoom-out-95 radix-state-open:fade-in-0 radix-state-open:zoom-in-95\" +\n      \" data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n  },\n  variants: {\n    appearance: {\n      normal: { content: \"\" },\n      inverted: { content: \"bg-foreground text-background\" },\n    },\n    size: {\n      small: { content: \"text-xs p-2\" },\n      medium: { content: \"text-sm p-3\" },\n      large: { content: \"text-base p-4\" },\n    },\n  },\n  defaultVariants: {\n    appearance: \"normal\",\n    size: \"medium\",\n  },\n})\n\nconst { content } = popoverSlots()\n\ntype PopoverContextValue = {\n  open: boolean\n  setOpen: (open: boolean) => void\n  openOnHover?: boolean\n  openOnContext?: boolean\n  inline?: boolean\n  withArrow?: boolean\n  size?: \"small\" | \"medium\" | \"large\"\n  appearance?: \"normal\" | \"inverted\"\n  positioning?: ComponentProps<typeof Content>[\"side\"]\n  mouseLeaveDelay?: number\n}\n\nconst PopoverContext = React.createContext<PopoverContextValue | null>(null)\n\nexport function Popover({\n  open,\n  defaultOpen,\n  onOpenChange,\n  openOnHover = false,\n  openOnContext = false,\n  closeOnScroll = false,\n  closeOnIframeFocus = false,\n  inline = false,\n  trapFocus = false,\n  withArrow = false,\n  appearance = \"normal\",\n  size = \"medium\",\n  positioning = \"bottom\",\n  mouseLeaveDelay = 0,\n  ...props\n}: React.ComponentProps<typeof Root> & {\n  openOnHover?: boolean\n  openOnContext?: boolean\n  closeOnScroll?: boolean\n  closeOnIframeFocus?: boolean\n  inline?: boolean\n  trapFocus?: boolean\n  withArrow?: boolean\n  appearance?: \"normal\" | \"inverted\"\n  size?: \"small\" | \"medium\" | \"large\"\n  positioning?: ComponentProps<typeof Content>[\"side\"]\n  mouseLeaveDelay?: number\n}) {\n  const isControlled = open !== undefined\n  const [internalOpen, setInternalOpen] = useState<boolean>(defaultOpen ?? false)\n  const isOpen = isControlled ? open : internalOpen\n\n  function setOpen(nextOpen: boolean) {\n    if (!isControlled) {\n      setInternalOpen(nextOpen)\n    }\n    onOpenChange?.(nextOpen)\n  }\n\n  useEffect(() => {\n    if (!closeOnScroll || !isOpen) return\n    function handleScroll() {\n      setOpen(false)\n    }\n    window.addEventListener(\"scroll\", handleScroll, true)\n    return () => window.removeEventListener(\"scroll\", handleScroll, true)\n  }, [closeOnScroll, isOpen])\n\n  useEffect(() => {\n    if (!closeOnIframeFocus || !isOpen) return\n    function handleBlur() {\n      setOpen(false)\n    }\n    window.addEventListener(\"blur\", handleBlur)\n    return () => window.removeEventListener(\"blur\", handleBlur)\n  }, [closeOnIframeFocus, isOpen])\n\n  return (\n    <PopoverContext.Provider\n      value={{\n        open: isOpen,\n        setOpen,\n        openOnHover,\n        openOnContext,\n        inline,\n        withArrow,\n        size,\n        appearance,\n        positioning,\n        mouseLeaveDelay,\n      }}\n    >\n      <Root data-slot=\"popover\" open={isOpen} onOpenChange={setOpen} modal={trapFocus} {...props} />\n    </PopoverContext.Provider>\n  )\n}\n\nexport function PopoverTrigger({\n  onPointerEnter,\n  onPointerLeave,\n  onContextMenu,\n  ...props\n}: React.ComponentProps<typeof Trigger>) {\n  const context = React.useContext(PopoverContext)\n  const leaveTimeout = useRef<number | null>(null)\n\n  function clearLeaveTimeout() {\n    if (leaveTimeout.current) {\n      window.clearTimeout(leaveTimeout.current)\n      leaveTimeout.current = null\n    }\n  }\n\n  return (\n    <Trigger\n      data-slot=\"popover-trigger\"\n      onPointerEnter={(event) => {\n        clearLeaveTimeout()\n        if (context?.openOnHover) {\n          context.setOpen(true)\n        }\n        onPointerEnter?.(event)\n      }}\n      onPointerLeave={(event) => {\n        if (context?.openOnHover) {\n          const delay = context.mouseLeaveDelay ?? 0\n          leaveTimeout.current = window.setTimeout(() => {\n            context.setOpen(false)\n          }, delay)\n        }\n        onPointerLeave?.(event)\n      }}\n      onContextMenu={(event) => {\n        if (context?.openOnContext) {\n          event.preventDefault()\n          context.setOpen(true)\n        }\n        onContextMenu?.(event)\n      }}\n      {...props}\n    />\n  )\n}\n\nfunction PopoverAnchor({ ...props }: React.ComponentProps<typeof Anchor>) {\n  return <Anchor data-slot=\"popover-anchor\" {...props} />\n}\n\nexport function PopoverContent({\n  className,\n  align = \"center\",\n  sideOffset = 4,\n  container,\n  withArrow,\n  appearance,\n  size,\n  side,\n  children,\n  ...props\n}: ComponentProps<typeof Content> & {\n  container?: HTMLElement\n  withArrow?: boolean\n  appearance?: \"normal\" | \"inverted\"\n  size?: \"small\" | \"medium\" | \"large\"\n}) {\n  const context = React.useContext(PopoverContext)\n  const resolvedInline = context?.inline\n  const resolvedWithArrow = withArrow ?? context?.withArrow\n  const resolvedAppearance = appearance ?? context?.appearance\n  const resolvedSize = size ?? context?.size\n  const resolvedSide = side ?? context?.positioning\n  const { asChild } = props\n  const hasSingleChild = React.Children.count(children) === 1\n  const resolvedAsChild = asChild && hasSingleChild\n\n  const contentNode = (\n    <Content\n      data-slot=\"popover-content\"\n      align={align}\n      side={resolvedSide}\n      sideOffset={sideOffset}\n      className={content({ appearance: resolvedAppearance, size: resolvedSize, className })}\n      asChild={resolvedAsChild}\n      {...props}\n    >\n      {resolvedAsChild ? (\n        children\n      ) : (\n        <div className=\"relative\">\n          {children}\n          {resolvedWithArrow && <Arrow className=\"fill-current\" />}\n        </div>\n      )}\n    </Content>\n  )\n\n  if (resolvedInline) {\n    return contentNode\n  }\n\n  return <Portal container={container}>{contentNode}</Portal>\n}\n",
      "type": "registry:component"
    }
  ],
  "type": "registry:component"
}